{"0": {
    "doc": "Speech Recognition",
    "title": "Speech Recognition",
    "content": "# Speech Recognition `TODO` | Metric | Description |--------------------------------------+---------------------------------------------------------------| WER | Word Error Rate | Utterance False Positive Rate (uFPR) | Ratio of cases where non speech utterances were transcribed. | Utterance False Negative Rate (uFNR) | Ratio of cases where utterances where transcribed as silence. | ## Data schema `TODO`: Note about the `` situation in transcription. ## Usage ### Command Line Use the sub-command `asr` like shown below: ```shell eevee asr ./data/tagged.transcriptions.csv ./data/predicted.transcriptions.csv ``` ``` Value Support Metric WER 0.571429 6 Utterance FPR 0.500000 2 Utterance FNR 0.250000 4 ``` ### Python module `TODO` ",
    "url": "/eevee/metrics/asr.html",
    "relUrl": "/metrics/asr.html"
  },"1": {
    "doc": "Data Structures",
    "title": "Data Structures",
    "content": "# Data Structures Eevee works with CSV label dataframes with items as per [these definitions](https://github.com/skit-ai/dataframes/blob/master/protos/labels.proto). Since label dataframes have `id` for referring back to the data, we just focus on labels in this tool. These labels can be true labels of various kind or coming from predictions of different models. This page documents a few general notes about the label representation. Specific details are in the pages for different kinds of metrics [here](./metrics). ## Serialization Each row in the label dataframe CSV is of one of the types defined [here](https://github.com/skit-ai/dataframes/blob/master/protos/labels.proto). In cases where the field type are not primitives, we serialize items in JSON. In Python, this looks like the following: ```python import pandas as pd # Assuming each item in `items` is a list of entities rows = [{\"id\": i, \"entities\": json.dumps(it)} for i, it in enumerate(items)] pd.DataFrame(rows).to_csv(\"./predictions.csv\", index=False) ``` The following is how correctly serialized structure looks like in a labels CSV: ``` \"[[{\"\"am_score\"\": -278.4794, \"\"confidence\"\": 0.9739978, \"\"lm_score\"\": 13.827044, \"\"transcript\"\": \"\"no\"\"}]]\" ``` If you skip JSON dumping, tools like pandas might still serialize like following: ``` \"[[{'am_score': -278.4794, 'confidence': 0.9739978, 'lm_score': 13.827044, 'transcript': 'no'}]]\" ``` But this won't be read back in `eevee` and you will get a `JSONDecodeError` ``` JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 4 (char 3) ``` ",
    "url": "/eevee/data-structures.html",
    "relUrl": "/data-structures.html"
  },"2": {
    "doc": "Metrics",
    "title": "Metrics",
    "content": " ",
    "url": "/eevee/metrics/",
    "relUrl": "/metrics/"
  },"3": {
    "doc": "Home",
    "title": "Home",
    "content": "# Eevee ![](https://img.shields.io/github/v/tag/skit-ai/eevee.svg?style=flat-square) ![GitHub Workflow Status](https://img.shields.io/github/workflow/status/skit-ai/eevee/CI?style=flat-square) `eevee` is a set of standard evaluation utilities for problems that we work on at [Skit](https://skit.ai). You can use `eevee` both as a python module or as a CLI tool. It works on data files with label structures from [dataframes](https://github.com/skit-ai/dataframes) that has standard datatype definitions. See `./data` directory for example files. ## Installation For now, you have to install eevee using Github release URLs. The current version can be installed by using the following: ```bash pip install https://github.com/skit-ai/eevee/releases/download/1.0.0/eevee-1.0.0-py3-none-any.whl ``` ## Usage Once installed, the most common usage pattern involves passing a reference and predicted label dataframes and get report either for human viewing, or get a json for further machine consumption. Here is how you use it for intents: ```bash eevee intent ./tagged.intent.csv ./predicted.intent.csv ``` Similarly, for WER report you can do this: ```bash eevee asr ./data/tagged.transcriptions.csv ./data/predicted.transcriptions.csv ``` ``` Value Support Metric WER 0.571429 6 Utterance FPR 0.500000 2 Utterance FNR 0.250000 4 ``` There are a few advanced unexposed metrics related to ASR. Since they are still work in progress, we have kept a few dependencies from there as _extras_. If you need those, you should install the package in development mode and do `poetry install -E asr`. Then follow the scripts in `./scripts`. ",
    "url": "/eevee/",
    "relUrl": "/"
  },"4": {
    "doc": "Intents",
    "title": "Intents",
    "content": "# Intents `TODO` ## Data Schema `TODO` ## Usage ### Command Line Call the sub-command `intent` like shown below: ```shell eevee intent ./true-labels.csv ./pred-labels.csv ``` ### Python module `TODO` ",
    "url": "/eevee/metrics/intents.html",
    "relUrl": "/metrics/intents.html"
  },"5": {
    "doc": "Roadmap",
    "title": "Roadmap",
    "content": "# Roadmap ... ",
    "url": "/eevee/roadmap.html",
    "relUrl": "/roadmap.html"
  },"6": {
    "doc": "Entities and Slots",
    "title": "Entities and Slots",
    "content": "Refer to [this](https://github.com/skit-ai/onboarding/blob/master/ml/slot-reporting/slot-evaluation-and-reporting.ipynb) document to understand more about slots, entities, and their metrics. # Slots `TODO` # Entities Eevee let's you calculate all the important _turn level metrics_ for various entities. We tag these data points using tog's, an internal tool, region tagging method. | Metric | Description |---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| False Negative Rate (FNR) | Ratio of turns where we missed out predicting an entity while the utterance had it. | False Positive Rate (FPR) | Ratio of turns where we predicted an entity while the utterance didn't have it. This usually needs attention in normalization by clearly defining what all states are going to be sampled for evaluation. | Mismatch Rate (MMR) | Within entity predictions, the ratio of cases that are differing in value. For example we predicted '3' instead of '2' for a `number` entity. | Here is the list of entities that are supported: | Type | Support remarks |----------------------------+-----------------| `datetime`, `date`, `time` | internally `datetime` (given) is broken down to `date` and `time`, therefore false positives, false negatives, true positives are considered along `date` & `time` and reported outside. | `pattern` | not yet supported | `number` | supported superficially only. `number` and `people` are supported interchangeably at this point. | ## Data schema either `true-labels.csv` or `pred-labels.csv` should have rows like these: ``` id, entities 1, '[{\"type\": \"date\", \"values\": [{\"value\": \"2019-04-21T00:00:00+05:30\", \"type\": \"value\"}]}]' 2, '[{\"text\": \"6th evening\", \"type\": \"time\", \"values\": [{\"type\": \"interval\", \"value\": {\"from\": \"2021-08-06T18:00:00.000-07:00\", \"to\": \"2021-08-07T00:00:00.000-07:00\"}}]}]' 3, 4, '[{\"text\": \"67\", \"type\": \"number\", \"values\": [{\"type\": \"value\", \"value\": 67}]}]' 5, '[{\"text\": \"want credit card\", \"type\": \"product_kind\", \"values\": [{\"type\": \"categorical\", \"value\": \"credit_card\"}]}]' ``` the `entities` are in `JSON` format. exact schema of entity looks like this: for ordinary `value` or `categorical` types: ``` [ { \"type\": \"entity_type\", # date, time, datetime, number, people, product_kind, etc... \"values\": [ { \"value\": \"entity_value\", # \"2019-04-21T00:00:00+05:30\", 42, credit_card, etc \"type\": \"entity_value_type\", # \"type\" or \"categorical\" } ] } ] ``` for `interval` value type: ``` [ { \"type\": \"entity_type\", # date, time, datetime only \"values\": [ { \"value\": {\"from\": \"...\", \"to\": \"...\"}, \"type\": \"interval\", } ] } ] ``` Three important things to note: * we require only entity's `type`, `values` for calculating the `entity_report`, the `body` / `text` or any other key is not required as of now. * if no-prediction / no-annotation has been made for that particular entity leave it blank, pandas will parse it as `NaN`, accordingly it'll be processed as false negative / false positive. * Right now, we only support only one `value`, meaning we compare truth and prediction only on the first duckling prediction. Implies our comparisons right now for entities looks likes: `[{}]` vs `[{}]`, in future we'd be supporting `[{}, {}]` vs `[{}, {}, {}, {}, {}]` ## Usage ### Command Line For using it on command line, simply call the sub-command `entity` like shown below: ```shell eevee entity ./true-labels.csv ./pred-labels.csv ``` on standard entities like `date`, `time`, `datetime`, `number` etc .. ``` FPR FNR Mismatch Rate Support Negatives Entity duration 0.004854 0.00000 0.000000 0 618 number 0.070033 0.00000 0.500000 4 614 ordinal 0.006515 1.00000 0.000000 4 614 time 0.016822 0.13253 0.055556 83 535 ``` on categorical custom entities from clients ... ``` FPR FNR Mismatch Rate Support Negatives Entity actions 0.004848 0.294118 0.000000 17 14025 form_type 0.000997 0.500000 0.000000 6 14036 language 0.001567 0.000000 0.000000 0 14042 method_type 0.000071 1.000000 0.000000 8 14034 product_kind 0.041297 0.141987 0.076258 3775 10267 ``` only on categorical entities we can get extra `breakdown` (pass `--breakdown` flag), which will report entity mismatches on their categorical values, example: ``` $ eevee entity data/cat_tog999.tagged.entities.csv data/cat_tog999.predicted.entities.csv --breakdown precision recall f1-score support Categorical Entity _ 0.949898 0.952032 0.950964 10236 actions/change 0.063492 0.666667 0.115942 6 actions/increase 0.470588 0.727273 0.571429 11 form_type/form 0.125000 0.500000 0.200000 4 form_type/request_form 1.000000 0.500000 0.666667 2 method_type/digital_payment 0.000000 0.000000 0.000000 8 product_kind/bank_account 0.797897 0.868957 0.831912 786 product_kind/card 0.240000 0.821918 0.371517 73 product_kind/cheque_book 0.848485 0.823529 0.835821 34 product_kind/credit_card 0.915548 0.797370 0.852382 2053 product_kind/debit_card 0.877686 0.713710 0.787250 744 product_kind/imps 1.000000 1.000000 1.000000 1 product_kind/mobile_banking 0.444444 0.571429 0.500000 7 product_kind/neft 1.000000 0.333333 0.500000 3 product_kind/net_banking 0.311828 0.725000 0.436090 40 product_kind/upi 0.857143 0.529412 0.654545 34 ``` where `_` represents `NaN` vs `NaN` comparisons. this helps with understanding when it comes to misfiring on no-entities. ### Python module A common usage pattern for ML modeling is to use entity comparison functions from `eevee.ord.entity` module. A demonstration on how to use `date_eq` and `time_eq`: ```python >>> from eevee.ord.entity.datetime import date_eq, time_eq >>> >>> true_date = {'type': 'date', 'values': [{'value': '2019-04-21T00:00:00+05:30', 'type': 'value'}]} >>> pred_date = {'type': 'date', 'values': [{'value': '2019-04-21T00:00:00+05:30', 'type': 'value'}]} >>> date_eq(true_date, pred_date) True >>> true_time = {'type': 'time', 'values': [{'value': '2019-04-21T09:00:00+05:30', 'type': 'value'}]} >>> pred_time = {'type': 'time', 'values': [{'value': '2019-04-21T00:00:00+05:30', 'type': 'value'}]} >>> time_eq(true_time, pred_time) False ``` ",
    "url": "/eevee/metrics/slots.html",
    "relUrl": "/metrics/slots.html"
  }
}
